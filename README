Исходное задание:
Написать вебсервис-шлюз на java.
Возвращает погоду для заданного места (страна, город). Для получения реальных данных воспользоваться любым другим сервисом.
Усложнения:
1. Предусмотреть каким образом будет обрабатываться нагрузка. Пик 1000 вызовов в секунду.
2. Что делать если сторонний сервис будет асинхронным. Каким образом сделать задержку и не захватить все ресурсы при нагрузке.

Решение:
Для решения этой проблемы была выбрана технология J2EE.

Методика реализации.
Так как нагрузка в пике - 1000 вызовов в секунду, каждый из которых сам по себе может длиться некоторое весомое продолжительное время - которое необходимо для общения с внешним веб-сервисом, да еще и асинхронным по ТЗ, то тут конечно можно наткнуться на огромное скопление "висящих" подключений - что в результате может привести к сбою системы. Чтобы избежать сбоев в этом случае наилучшим решением которое пришло мне в голову - сделать также асинхронный сервис. Принцип работы следующий.

От некоторого клиента приходит запрос к веб сервису. 
Веб сервис присваивает идентификатор данному запросу.
Веб сервис помещает этот запрос в очередь и возвращает клиенту идентификатор запроса. 
Из очереди сообщение поступает на обработку.
После обработки, система помещает обработанный запрос в хранилище.
Клиент снова обращается к веб сервису, указывая идентификатор запроса. 
Если запрос с заданным идентификатором к этому моменту обработан системой - система возвращает результат обработки. Если нет - возвращается признак того, что запрос не обработан.
Внешний клиент может периодически обращаться к веб сервису для получения данных по идентификатору, пока наконец их не получит. 


В качестве решения я использовал веб сервис на базе J2EE.
В качестве очереди используется JMS очередь на основе Message Driven Bean.
Запрос из веб сервиса передается в JMS очередь, после чего возвращается управление - в результате коннект не подвешивается и не расходуются больше ресурсы системы для взаимодействия с клиентом пока идет обработка запроса.
Так как запросов может быть очень много платформа JMS легко расширяется и может масштабироваться до тех пределов, пока не будет настигнут нужный уровень производительности.

Это касается как веб сервиса, который должен уметь обработать 1000 запросов в секунду, так и JMS очереди. В случае необходимости Application Server расширит пул JMS бинов, которые эту очередь обслуживают. В результате получается весьма экономное использование ресурсов системы, с возможностью наращивания производительности до необходимого уровня.

Далее, когда запрос будет обработан Message Driven бином, он поступит в хранилище. Хранилище устроено примитивно - это по сути хранилище по ключу - идентификатору, в качестве значения выступает обработанный запрос - результат, пришедший от другой внешней системы - в данной реализации в соответствии с заданием - это веб сервис получения погоды. Но вообще это может быть любая другая внешняя система, в том числе и асинхронный веб сервис. Сам механизм, поддерживающий хранилище - также может быть усовершенствован. Можно добавить удаление из хранилища неактуальных запросов (время жизни ответа) - чтобы хранилище не разрасталось до непозволительных пределов. Сейчас предусмотрено, что если клиент забрал свой ответ, то данные удаляются из хранилища.

Клиенты периодически опрашивают систему на предмет получения результата, или отправку запроса. Эти запросы сами по себе не будут практически нагружать систему по сравнению с другими операциями, отвечающими за обработку запроса. По сути - это короткие запросы, которые сами по себе очень легкие. В основном ресурсы уйдут на обслуживание очереди - по нагрузке, а также на получение ответа от внешней системы - по времени - который может оказаться сравнительно долгим в случае асинхронного веб сервиса, к примеру, который также относительно надолго может подвесить систему. Но это не проблема для J2EE платформы - так как в этом случае система просто создаст большее количество бинов для обслуживания очереди. Сама система имеет массу возможностей мониторинга нагрузки, что позволяет нам принимать объективные решения по дальнейшему улучшению производительности.

Таким образом решается как первая, так и вторая проблема, которая выступает усложнением веб сервиса из задания. К тому же есть еще масса преимуществ. Система будет работать стабильно с возможностью пропорционального наращивания мощности до нужного уровня в случае необходимости. 

К тому же с появлением EJB 3.1 - данные возможности легко реализуются. Платформа все инфраструктурные вопросы решает сама. Остается сосредоточиться лишь на бизнес логике. Решение легкое, простое, надежное. Легко расширяется с появлением новых требований, легко масштабируется - путем добавления в кластер нового сервера, стабильно работает.

Возможно можно придумать решение и лучше и усовершенствовать сам механизм подключения и ожидания. Возможно. Предложенное решение решает поставленную задачу. И это решение можно также совершенствовать на основе каких-то еще более продвинутых идей.

О самом веб сервисе.
Веб сервис имеет два веб метода. 
первый метод принимает на вход два параметра: имя страны (на английском), имя города (также). На выходе - идентификатор запроса.
Второй веб метод - для получения по идентификатору ответа.
В ответе - погодные условия в заданном регионе в формате XML.


Вариант веб сервиса для исходного задания.

J2EE проект.
В качестве среды разработки использовался NetBeans. В качестве сервера приложений - Glassfish 3+.

Для запуска проекта потребуется Application Server.
Необходимо задеплоить разработанный EJB Bean на Application Server.

Инструкция как задеплоить на Glassfish (очень кратко).
1. Установить сервер приложений Glassfish 3+. 
2. Зайти в консоль администратора

3. Перед тем как деплоить непосредственно сам Bean , необходимо сконфигурировать некоторые ресурсы в Glassfish.
Конфигурирование ресурсов.

3.1
После входа в веб консоль администратора перейти на вкладку
JMS Resources / Connection Factories
Выбрать опцию "New.."

Для соответствующих полей ввести/выбрать данные:
Pool Name:  jms/drqFactoryPool
JNDI Name:  jms/drqFactoryPool
Resource Type:   javax.jms.QueueConnectionFactory

3.2
Перейти на вкладку
JMS Resources / Destination Resources

Выбрать опцию "New.."
Для соответствующих полей ввести/выбрать данные:
JNDI Name: jms/drq
PhusicalQueue: PhysicalQueue
Resource Type: javax.jms.Queue

3.3
Resources / Connectors / Connector Resources
Удалить коннектор jms/drqFactoryPool (если он там есть, скорее всего есть)

Выбрать опцию "New.."
Для соответствующих полей ввести/выбрать данные:
JNDI Name: jms/drqFactory
Pool Name: jms/drqFactoryPool

4. Перейти на вкладку Applications, выбрать опцию Deploy..
Из списка файлов надо выбрать 1 файл: WeatherEJBWebService\WeatherEJBWebService-ejb\dist\WeatherEJBWebService-ejb.jar 
Нажать ок - приложение должно задеплоиться на сервер. После чего оно появится в списке среди Deployed Applications на вкладке Applications с именем WeatherEJBWebService-ejb


Для проверки веб методов можно использовать средства самого Application Servera Glassfish.
Для этого нужно перейти по ссылке, кликнуть на задеплоенное приложение. Откроется список компонентов приложения.
Рядом с компонентом WeatherWebService в колонке Action надо кликнуть по ссылке View Endpoint.
После перехода кликнуть по ссылке Tester. На следующей странице выбрать вариант тестирования для http.
На следующей странице появятся 2 метода веб сервиса. 

